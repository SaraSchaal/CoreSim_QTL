---
title: "Process Single Sim File"
author: "Sara Michele Schaal"
date: "2/10/2021"
output: html_document
---

## Load Packages and Download Data Files ##
```{r}
options(scipen = 999)
## List Packages Needed 
packages_needed <- c("IntegratedMRF", "vcfR", "distances","ggplot2", "metR", "fields",
                     "MultivariateRandomForest", "gridExtra", "akima",
                     "MLmetrics", "ash", "plotly", "stringr", "tidyverse",
                     "bigsnpr", "bigstatsr", "ggpubr", "purrr", "dplyr")

## install packages that aren't installed already
for (i in 1:length(packages_needed)){
  if(!(packages_needed[i] %in% installed.packages())){install.packages(packages_needed[i])}
}

## load each library
for (i in 1:length(packages_needed)){
  library( packages_needed[i], character.only = TRUE)
}

# download data
 folder <- "results/Inversion/20210220_inOutInvFST/"
 #folder <- "results/20210129_Movie/"
 seed <- "3384725"
 #df.params <- read.table("src/InvSimParams.txt", header = TRUE)
 df.invTime <- read.table(paste0(folder, seed, "_outputInvTime.txt", sep = ""), header = TRUE)
 df.invData <- read.table(paste0(folder, seed, "_outputInvSumInfo.txt", sep = ""), header = TRUE)
 df.muts <- read.table(paste0(folder, seed, "_outputMutations.txt", sep = ""), header = TRUE)
 df.popDyn <- read.table(paste0(folder, seed, "_outputPopDynam.txt", sep = ""), header = TRUE)
 df.indPheno <- read.table(paste0(folder, seed, "_outputIndPheno.txt", sep = ""), header = TRUE)
 df.invQTNData <- read.table(paste0(folder, seed, "_outputInvQtnSumInfo.txt", sep = ""), header = TRUE)
 df.invQTNTime <- read.table(paste0(folder, seed, "_outputInvQtn.txt", sep = ""), header = TRUE)
 df.params <- read.table(paste0(folder, seed, "_outputSimStats.txt", sep = ""), header = FALSE)
 colnames(df.params) <- c("seed", "mig1", "mig2", "N1", "N2", "r", "muInv", 
                          "muBase", "alpha", "sigmaK", "burnin", "rep", "enVar")
 df.InvOrigin <- read.table(paste(folder, "3384725_outputOriginInvQtn.txt", sep = ""), header = TRUE)
 
 df.invTime.NS <- read.table(paste0(folder, seed, "noSel_outputInvTime.txt", sep = ""), header = TRUE)
 df.invData.NS <- read.table(paste0(folder, seed, "noSel_outputInvSumInfo.txt", sep = ""), header = TRUE)
 df.muts.NS <- read.table(paste0(folder, seed, "noSel_outputMutations.txt", sep = ""), header = TRUE)
 df.popDyn.NS <- read.table(paste0(folder, seed, "noSel_outputPopDynam.txt", sep = ""), header = TRUE)
```


# Calculate average length, age and size of inversions 
```{r}

### Manipulate data frames for merging
### SELECTION ###
  df.invAllDatatemp <- merge(df.invData, df.invTime, by.x = c("inv_id"), 
                         by.y = c("inv_id"), all.y = TRUE)
  colnames(df.invAllDatatemp)[7] <- "sim_gen"
  df.invAllData <- df.invAllDatatemp[,-2]
  df.invAllData$inv_age <- df.invAllData$sim_gen - df.invAllData$inv_originGen
  
### NO SELECTION ###
  df.invAllDatatemp.NS <- merge(df.invData.NS, df.invTime.NS, by.x = c("inv_id"), 
                         by.y = c("inv_id"), all.y = TRUE)
  colnames(df.invAllDatatemp.NS)[9] <- "sim_gen"
  df.invAllData.NS <- df.invAllDatatemp.NS[,-2]
  df.invAllData.NS$inv_age <- df.invAllData.NS$sim_gen - df.invAllData.NS$inv_originGen
 
```


## Subset inversions by FST values
```{r}
#############################################################################################################
#### Subset Inversions ####

### SELECTION SIMS ###
## Top 10 percent of FST values
 top10.data <- df.invAllData %>%
    group_by(sim_gen) %>%
    filter(inv_FST>=quantile(inv_FST, 0.9)) %>%
    summarise_at(c("inv_age", "mean_qtnSelCoef", "num_qtns", "inv_length"), 
                 mean, .groups = "keep") %>%
    rename(inv_ageT10 = inv_age, mean_qtnSelCoefT10 = mean_qtnSelCoef, 
           num_qtnsT10 = num_qtns, inv_lengthT10 = inv_length)

  top10.data.nosum <- df.invAllData %>%
    group_by(sim_gen) %>%
    filter(inv_FST>=quantile(inv_FST, 0.9))
  
## Bottom 90 percent of FST values
  bottom90.data <- df.invAllData %>%
    group_by(sim_gen) %>%
    filter(inv_FST<quantile(inv_FST, 0.9)) %>%
    summarise_at(c("inv_age", "mean_qtnSelCoef", "num_qtns", "inv_length"), 
                 mean, .groups = "keep") %>%
    rename(inv_ageB90 = inv_age, mean_qtnSelCoefB90 = mean_qtnSelCoef, 
           numqtnsB90 = num_qtns, inv_lengthB90 = inv_length) 
  
     bot90.data.nosum <- df.invAllData %>%
      group_by(sim_gen) %>%
       filter(inv_FST<quantile(inv_FST, 0.9))
       # summarise_at(c("num_qtns","mean_qtnSelCoef", "num_qtns", "inv_length"), 
       #            sd, .groups = "keep") %>%
       # rename(inv_ageSDB90 = inv_age, SD_qtnSelCoefB90 = mean_qtnSelCoef, 
       #      numqtnsSDB90 = num_qtns, inv_lengthSDB90 = inv_length)
                      
     
    sd.Top10 <- aggregate(cbind(num_qtns, mean_qtnSelCoef, num_qtns, inv_length)~sim_gen, 
               data = top10.data.nosum, FUN = sd)
    colnames(sd.Top10)[2:5] <- c("sd_inv_ageT10", "sd_qtnSelCoefT10", "sd_num_qtnsT10", "sd_inv_lengthT10")
    sd.Bottom90 <- aggregate(cbind(num_qtns, mean_qtnSelCoef, num_qtns, inv_length)~sim_gen, 
               data = bot90.data.nosum, FUN = sd)
    colnames(sd.Bottom90)[2:5] <- c("sd_inv_ageB90", "sd_qtnSelCoefB90", "sd_num_qtnsB90", "sd_inv_lengthB90")              
  
## Join dataframes with parameters
  df.FSTsplitTb <- full_join(top10.data, bottom90.data, by = "sim_gen")
  
## convert to data frame and factor parameter columns
  df.FSTsplitTemp <- as.data.frame(df.FSTsplitTb)  
  df.FSTsplitTemp2 <- full_join(df.FSTsplitTemp, sd.Top10, by = "sim_gen")
  df.FSTsplit <- full_join(df.FSTsplitTemp2, sd.Bottom90, by = "sim_gen")
  
### NO SELECTION SIMS ###
## Top 10 percent of FST values
 top10.data.NS <- df.invAllData.NS %>%
    group_by(sim_gen) %>%
    filter(inv_FST>=quantile(inv_FST, 0.9)) %>%
    summarise_at(c("inv_age", "mean_qtnSelCoef", "num_qtns", "inv_length"), 
                 mean, .groups = "keep") %>%
    rename(inv_ageT10 = inv_age, mean_qtnSelCoefT10 = mean_qtnSelCoef, 
           num_qtnsT10 = num_qtns, inv_lengthT10 = inv_length)
 
 top10.data.nosum.NS <- df.invAllData.NS %>%
    group_by(sim_gen) %>%
    filter(inv_FST>=quantile(inv_FST, 0.9)) 
  
## Bottom 90 percent of FST values
  bottom90.data.NS <- df.invAllData.NS %>%
    group_by(sim_gen) %>%
    filter(inv_FST<quantile(inv_FST, 0.9)) %>%
    summarise_at(c("inv_age", "mean_qtnSelCoef", "num_qtns", "inv_length"), 
                 mean, .groups = "keep") %>%
    rename(inv_ageB90 = inv_age, mean_qtnSelCoefB90 = mean_qtnSelCoef, 
           numqtnsB90 = num_qtns, inv_lengthB90 = inv_length) 
  
  bot90.data.nosum.NS <- df.invAllData.NS %>%
                  group_by(sim_gen) %>%
                  filter(inv_FST<quantile(inv_FST, 0.9)) 
        # summarise_at(c("inv_age", "mean_qtnSelCoef", "num_qtns", "inv_length"), 
        #             sd, .groups = "keep") %>%
        # rename(inv_ageSDB90 = inv_age, SD_qtnSelCoefB90 = mean_qtnSelCoef, 
        #      numqtnsSDB90 = num_qtns, inv_lengthSDB90 = inv_length)
     
    sd.Top10.NS <- aggregate(cbind(inv_age, mean_qtnSelCoef, num_qtns, inv_length)~sim_gen, 
               data = top10.data.nosum.NS, FUN = sd)
    colnames(sd.Top10.NS)[2:5] <- c("sd_inv_ageT10", "sd_qtnSelCoefT10", "sd_num_qtnsT10", "sd_inv_lengthT10")
    sd.Bottom90.NS <- aggregate(cbind(inv_age, mean_qtnSelCoef, num_qtns, inv_length)~sim_gen, 
               data = bot90.data.nosum.NS, FUN = sd)
    colnames(sd.Bottom90.NS)[2:5] <- c("sd_inv_ageB90", "sd_qtnSelCoefB90", "sd_num_qtnsB90", "sd_inv_lengthB90")
  
## Join dataframes with parameters
  df.FSTsplit.NSTb <- full_join(top10.data.NS, bottom90.data.NS, by = "sim_gen")
  
## convert to data frame and factor parameter columns
  df.FSTsplit.NStemp <- as.data.frame(df.FSTsplit.NSTb)  
  df.FSTsplit.NStemp2 <- full_join(df.FSTsplit.NStemp, sd.Top10.NS, by = "sim_gen")
  df.FSTsplit.NS <- full_join(df.FSTsplit.NStemp2, sd.Bottom90.NS, by = "sim_gen")
  
```

# Plotting

## Plotting for Local Adaptation
```{r}
#########################################################################################################
#### PLOTTING For Population Demographics ####
#############################################################################################################
# This function saves the legend into an object to use for plotting as an element in ggarrange
g_legend<-function(myggplot){
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

## Local adaptation
LA.plot <- ggplot(data = df.popDyn, 
       aes(x = sim_gen, y = localAdaptSA)) + 
       geom_line(color = "cadetblue3", size = 0.75) + 
       geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
       labs(title = paste("Local Adaptation - mig =", df.params$mig1, "muInv =", 
                          df.params$muInv, "\nmuBase =", df.params$muBase, "alpha =",
                          df.params$alpha, "\nsigmaK =", df.params$sigmaK, "enVar =", df.params$enVar),
            y = "Local Adaptation",
            x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits = c(-0.1, 1))


## Phenotypes
## TRY MAKING THIS A SINGLE TWO PANEL PLOT WITH TWO LINES ON EACH FOR THE TWO POPULATIONS
phenoP1.plot <- ggplot(data = df.popDyn, 
                     aes(x = sim_gen, y = meanPhenoP1)) + 
       geom_line(color = "cadetblue3", size = 0.75) + 
       geom_line(aes(y = meanPhenoP1 + sdPhenoP1, x = sim_gen), color = "lightgrey") + 
       geom_line(aes(y = meanPhenoP1 - sdPhenoP1, x = sim_gen), color = "lightgrey") + 
       geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
       labs(title = "Population 1", y = "Phenotype", x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits = c(min(df.popDyn$meanPhenoP2 - df.popDyn$sdPhenoP2- 0.1),
                                                       max(df.popDyn$meanPhenoP1 + df.popDyn$sdPhenoP1 + 0.1)))

phenoP2.plot <- ggplot(data = df.popDyn, 
                     aes(x = sim_gen, y = meanPhenoP2)) + 
       geom_line(color = "navy", size = 0.75) + 
       geom_line(aes(y = meanPhenoP2 + sdPhenoP2, x = sim_gen), color = "lightgrey") + 
       geom_line(aes(y = meanPhenoP2 - sdPhenoP2, x = sim_gen), color = "lightgrey") + 
       geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
       labs(title = "Population 2", y = "Phenotype", x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits = c(min(df.popDyn$meanPhenoP2 - df.popDyn$sdPhenoP2- 0.1),
                                                       max(df.popDyn$meanPhenoP1 + df.popDyn$sdPhenoP1 + 0.1)))

ggarrange(phenoP1.plot, phenoP2.plot)

phenoP1.plot.NS <- ggplot(data = df.popDyn.NS, 
                     aes(x = sim_gen, y = meanPhenoP1)) + 
       geom_line(color = "cadetblue3", size = 0.75) + 
       geom_line(aes(y = meanPhenoP1 + sdPhenoP1, x = sim_gen), color = "lightgrey") + 
       geom_line(aes(y = meanPhenoP1 - sdPhenoP1, x = sim_gen), color = "lightgrey") + 
       geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
       labs(title = "Population 1 - No Selection", y = "Phenotype", x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits = c(min(df.popDyn$meanPhenoP2 - df.popDyn$sdPhenoP2- 0.1),
                                                       max(df.popDyn$meanPhenoP1 + df.popDyn$sdPhenoP1 + 0.1)))

phenoP2.plot.NS <- ggplot(data = df.popDyn.NS, 
                     aes(x = sim_gen, y = meanPhenoP2)) + 
       geom_line(color = "navy", size = 0.75) + 
       geom_line(aes(y = meanPhenoP2 + sdPhenoP2, x = sim_gen), color = "lightgrey") + 
       geom_line(aes(y = meanPhenoP2 - sdPhenoP2, x = sim_gen), color = "lightgrey") + 
       geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
       labs(title = "Population 2 - No Selection ", y = "Phenotype", x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits = c(min(df.popDyn$meanPhenoP2 - df.popDyn$sdPhenoP2- 0.1),
                                                       max(df.popDyn$meanPhenoP1 + df.popDyn$sdPhenoP1 + 0.1)))
ggarrange(phenoP1.plot.NS, phenoP2.plot.NS)

## Fitnesses
fitP1.plot <- ggplot(data = df.popDyn, 
                     aes(x = sim_gen, y = meanFitP1)) + 
       geom_line(color = "cadetblue3", size = 0.75) + 
       geom_line(aes(y = meanFitP1 + sdFitP1, x = sim_gen), color = "lightgrey") + 
       geom_line(aes(y = meanFitP1 - sdFitP1, x = sim_gen), color = "lightgrey") + 
       geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
       labs(title = "Population 1", y = "Fitness", x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits =c((min(df.popDyn$meanFitP1 - df.popDyn$sdFitP1, 
                                                            df.popDyn$meanFitP2 - df.popDyn$sdFitP2) - 0.1),
                                                       ((max(df.popDyn$meanFitP1 + df.popDyn$sdFitP1, 
                                                             df.popDyn$sdFitP2 + df.popDyn$sdFitP2) + 0.1))))

fitP2.plot <- ggplot(data = df.popDyn, 
                     aes(x = sim_gen, y = meanFitP2)) + 
       geom_line(color = "navy", size = 0.75) + 
       geom_line(aes(y = meanFitP2 + sdFitP2, x = sim_gen), color = "lightgrey") + 
       geom_line(aes(y = meanFitP2 - sdFitP2, x = sim_gen), color = "lightgrey") + 
       labs(title = "Population 2", y = "Fitness", x = "Generation") +
       theme_classic() +
       theme(panel.background = element_blank(), 
             strip.background = element_rect(colour = "white", fill = "grey92")) +
       scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
       scale_y_continuous(expand = c(0, 0), limits = c((min(df.popDyn$meanFitP1 - df.popDyn$sdFitP1, 
                                                            df.popDyn$meanFitP2 - df.popDyn$sdFitP2) - 0.1),
                                                       ((max(df.popDyn$meanFitP1 + df.popDyn$sdFitP1, 
                                                             df.popDyn$sdFitP2 + df.popDyn$sdFitP2) + 0.1))))

ggarrange(fitP1.plot, fitP2.plot)

```

## Plotting for inversion characteristics
```{r}
#########################################################################################################
#### PLOTTING For inversion characteristics ####
#############################################################################################################

  ## plot inversion age --  split by inversiion FST with reps
   
    ### SELECTION ###
    df.invage <- pivot_longer(df.FSTsplit[, c(1,2,6,10,14)], cols = c(inv_ageT10, inv_ageB90,sd_inv_ageT10, sd_inv_ageB90),
                              names_to = "FSTsplit", values_to = "inv_age")
    inv.age.plot <- ggplot(data = df.invage, 
                           aes(x = sim_gen, y = inv_age, group = FSTsplit)) + 
                           geom_line(aes(color = FSTsplit), size = 0.75) + 
                           geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
                           labs(title = " ", y = "Average Inversion Age", x = "Generation") +
                           theme_classic() +
                           theme(panel.background = element_blank(), 
                                 strip.background = element_rect(colour = "white", fill = "grey92")) +
                           scale_color_manual(labels = c("Bot 90%", "Top 10%"), 
                                              values=c("darkseagreen4", "darkseagreen3", "darkgrey", "darkgrey")) +
                           theme(legend.position = "none") +
                           scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
                           scale_y_continuous(expand = c(0, 0), limits = c(0, max(df.FSTsplit$inv_ageT10)))
            
    ### NO SELECTION ###
    df.invage.NS <- pivot_longer(df.FSTsplit.NS[, c(1,2,6)], cols = c(inv_ageT10, inv_ageB90),
                                 names_to = "FSTsplit", values_to = "inv_age")
    
    inv.age.plot.NS <- ggplot(data = df.invage.NS, 
                               aes(x = sim_gen, y = inv_age, group = FSTsplit)) + 
                               geom_line(aes(color = FSTsplit), size = 0.75) + 
                               geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
                               labs(title = " ", y = "", x = "Generation") +
                               theme_classic() +
                               theme(panel.background = element_blank(), 
                                     strip.background = element_rect(colour = "white", fill = "grey92")) +
                               
                               scale_color_manual(labels = c("Bot 90%", "Top 10%"), 
                                                  values=c("darkseagreen4", "darkseagreen3")) +
                               scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
                               scale_y_continuous(expand = c(0, 0), limits = c(0, max(df.FSTsplit$inv_ageT10)))
   
    leg <- g_legend(inv.age.plot.NS)
    
    inv.age.plot.NS.noleg <- inv.age.plot.NS + theme(legend.position = "none")
    
    
    ggarrange(inv.age.plot, inv.age.plot.NS.noleg, leg, 
              labels = c("Selection", "No Selection"), ncol = 3, widths = c(2.3,2.3,0.8))
 
 ### Inversion Length ####
 #######################################
  
  # Selection   
    df.invlength <- pivot_longer(df.FSTsplit[, c(1,5,9)], cols = c(inv_lengthT10, inv_lengthB90),
                              names_to = "FSTsplit", values_to = "inv_length")
    inv.length.plot <- ggplot(data = df.invlength, 
                           aes(x = sim_gen, y = inv_length, group = FSTsplit)) + 
                           geom_line(aes(color = FSTsplit), size = 0.75, alpha = 0.9) + 
                           geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
                           labs(title = " ", y = "Average Inversion Length", x = "Generation") +
                           theme_classic() +
                           theme(panel.background = element_blank(), 
                                 strip.background = element_rect(colour = "white", fill = "grey92")) +
                           scale_color_manual(labels = c("Bot 90%", "Top 10%"),
                                              values=c("lightsalmon3", "lightsalmon1")) +
                           theme(legend.position = "none") +
                           scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
                           scale_y_continuous(expand = c(0, 0), limits = c(0, 50000))
            
    
    ### NO SELECTION ###
    df.invlength.NS <- pivot_longer(df.FSTsplit.NS[, c(1,5,9)], cols = c(inv_lengthT10, inv_lengthB90),
                                 names_to = "FSTsplit", values_to = "inv_length")
    
    inv.length.plot.NS <- ggplot(data = df.invlength.NS, 
                               aes(x = sim_gen, y = inv_length, group = FSTsplit)) + 
                               geom_line(aes(color = FSTsplit), size = 0.75, alpha= 0.9) + 
                               geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
                               labs(title = " ", y = "", x = "Generation") +
                               theme_classic() +
                               theme(panel.background = element_blank(), 
                                     strip.background = element_rect(colour = "white", fill = "grey92")) +
                               scale_color_manual(labels = c("Bot 90%", "Top 10%"),
                                                  values=c("lightsalmon3", "lightsalmon1")) +
                               scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
                               scale_y_continuous(expand = c(0, 0), limits = c(0, 50000))
    
    legLeng <- g_legend(inv.length.plot.NS)
    
    inv.length.plot.NS.noLeg <- inv.length.plot.NS + theme(legend.position = "none")
    
    ggarrange(inv.length.plot, inv.length.plot.NS.noLeg, legLeng, labels = c("Selection", "No Selection"),
              ncol = 3, widths = c(2.3,2.3,0.8))
   
### Inversion QTNs ####
#######################################   
  # Selection
    df.invQTNs <- pivot_longer(df.FSTsplit[, c(1,4,8)], cols = c(num_qtnsT10, numqtnsB90),
                              names_to = "FSTsplit", values_to = "inv_qtnNum")
    
    inv.qtns.plot <- ggplot(data = df.invQTNs, 
                               aes(x = sim_gen, y = inv_qtnNum, group = FSTsplit)) + 
                               geom_line(aes(color = FSTsplit), size = 0.75) + 
                               geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
                               labs(title = "",
                                     y = "Average Number of inversion QTNs",
                                     x = "Generation") +
                               theme_classic() +
                               theme(panel.background = element_blank(), 
                                     strip.background = element_rect(colour = "white", fill = "grey92")) +
                               #scale_color_discrete(name = "FST split", labels = 
                                #c("Top 10% FST", "Bottom 90% FST")) +
                               scale_color_manual(labels = c("Bot 90%", "Top 10%"), 
                                                  values=c( "thistle", "plum4")) +
                               theme(legend.position = "none") +
                               scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
                               scale_y_continuous(expand = c(0, 0), limits = c(0, max(df.invQTNs$inv_qtnNum)))

    
  # No Selection    
  df.invQTNs.NS <- pivot_longer(df.FSTsplit.NS[, c(1,4,8)], cols = c(num_qtnsT10, numqtnsB90),
                              names_to = "FSTsplit", values_to = "inv_qtnNum")

  inv.qtns.plot.NS <- ggplot(data = df.invQTNs.NS, 
                               aes(x = sim_gen, y = inv_qtnNum, group = FSTsplit)) + 
                               geom_line(aes(color = FSTsplit), size = 0.75) + 
                               geom_vline(xintercept = 10000, linetype = "dashed", color = "black") +
                               labs(title = " ", y = "", x = "Generation") +
                               theme_classic() +
                               theme(panel.background = element_blank(), 
                                     strip.background = element_rect(colour = "white", fill = "grey92")) +
                               scale_color_manual(labels = c("Bot 90%", "Top 10%"), 
                                                  values=c("thistle", "plum4")) +
                               scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) + 
                               scale_y_continuous(expand = c(0, 0), limits = c(0, max(df.invQTNs$inv_qtnNum)))
   
    legQTNs <- g_legend(inv.qtns.plot.NS)
    
    inv.qtns.plot.NS.noleg <- inv.qtns.plot.NS + theme(legend.position = "none")
  ggarrange(inv.qtns.plot, inv.qtns.plot.NS.noleg, legQTNs, labels = c("Selection", "No Selection"),
            ncol = 3, widths = c(2.3,2.3,0.8))

```


## Calculate inversion window
```{r}
# merge inversion data files together and remove the extra sim-gen column from metadata file
df.invAllData <- left_join(df.invTime, df.invData[,c(1,3:ncol(df.invData))], by = "inv_id")
df.invAllDataNS <- left_join(df.invTime.NS, df.invData.NS[,c(1,3:ncol(df.invData))], by = "inv_id")

# filter the inversion data to get the final generation
df.invDataFinalGen <- filter(df.invAllData, sim_gen == 50000)
df.invDataFinalGenNS <- filter(df.invAllDataNS, sim_gen == 50000)

# identify all the positions in the genome that are within the inversion windows
invWind <- function(x){
  invWindowBases <- NULL
  numSegInv <- 0
  for(i in 1:nrow(x)) {
    invWindowBases <- c(invWindowBases, seq(from = x$inv_pos[i], 
                                            to = x$inv_end[i], by = 1))
    numSegInv <- numSegInv + 1
  }
  
  # identify all the positions in the genome that are within the inversion windows
  # filtered for MAF of 0.01
  invWindowBasesMAF <- NULL
  numSegInvMAF <- 0
  for(i in 1:nrow(x)) {
    Inv_wtype_freq <-  1 - x$freq[i]					
    MAF <-  min(x$freq[i], Inv_wtype_freq)				
    if(MAF > 0.01){
      invWindowBasesMAF <- c(invWindowBasesMAF, seq(from = x$inv_pos[i], 
                                            to = x$inv_end[i], by = 1))
      numSegInvMAF <- numSegInvMAF + 1
    }
  }
  #segInv <- paste("number of segregating inversions =",  numSegInv, sep = " ")
  #segInvMAF <- paste("number of segregating inversions filtered for MAF 0.01 =",  numSegInvMAF, sep = " ")
  obj_list <- list("invWindBases" = invWindowBases, "invWindBasesMAF" = invWindowBasesMAF, 
                   "numSeqInv" = numSegInv, "numSeqInvMAF" = numSegInvMAF)
  return(obj_list)
}

invWindBases <- invWind(df.invDataFinalGen)[[1]]
invWindBasesNS <- invWind(df.invDataFinalGenNS)[[1]]

```

## Identify which QTNS fall inside inversion windows
```{r}
qtnMuts <- filter(df.muts, type == "m2")
qtnMuts.NS <- filter(df.muts.NS, type == "m2")

# identify which qtns overlap with inv window locations
invWinQTNrows <- which(qtnMuts$position %in% invWindBases)
invWinQTNrows.NS <- which(qtnMuts.NS$position %in% invWindBasesNS)

# use this to identify how many positions have multiple qtns 
mult.qtns <- length(which(qtnMuts$position %in% invWindBases)) - length(intersect(invWindBases, qtnMuts$position))
mult.qtns.NS <- length(which(qtnMuts.NS$position %in% invWindBasesNS)) - length(intersect(invWindBasesNS, qtnMuts.NS$position))

## Selection
for(i in 1:nrow(qtnMuts)){
  if(i %in% invWinQTNrows){
    qtnMuts$inOut[i] <- "in"
  } else {
    qtnMuts$inOut[i] <- "out"
  } 
}

neutMuts <- filter(df.muts, type == "m1")
neutMuts$inOut <- "neut"

df.neutQtnMuts <- rbind(qtnMuts, neutMuts)
df.neutQtnMuts$FST <- as.numeric(as.character(df.neutQtnMuts$FST))

## No selection
for(i in 1:nrow(qtnMuts.NS)){
  if(i %in% invWinQTNrows.NS){
    qtnMuts.NS$inOut[i] <- "in"
  } else {
    qtnMuts.NS$inOut[i] <- "out"
  } 
}

neutMuts.NS <- filter(df.muts.NS, type == "m1")
neutMuts.NS$inOut <- "neut"

df.neutQtnMuts.NS <- rbind(qtnMuts.NS, neutMuts.NS)
df.neutQtnMuts.NS$FST <- as.numeric(as.character(df.neutQtnMuts.NS$FST))


```

## Plot Manhattan plots
```{r}
## Selection
manh.plot <- ggplot(df.neutQtnMuts, aes(x = position, y = FST, group = inOut)) + 
                    geom_point(aes(color = inOut)) + 
                    scale_color_manual(values=c( "red", "goldenrod", "navy")) +
                    xlim(0, 2100000) + 
                    ylim(0, 0.2) +
                    theme(legend.position = "none")

## No Selection
manh.plot.NS <- ggplot(df.neutQtnMuts.NS, aes(x = position, y = FST, group = inOut)) + 
                    geom_point(aes(color = inOut)) + 
                    scale_color_manual(values=c( "red", "goldenrod", "navy")) +
                    xlim(0, 2100000) + 
                    ylim(0, 0.2) +
                    theme(legend.position = "none")

## ADD THE LEGEND AND CHROMOSOME COLORS
ggarrange(manh.plot, manh.plot.NS)

```


## Origin dynamics
```{r}
# Subset for final generation
df.invFinalGen <- subset(df.invTime, subset = sim_gen == 50000)

# get sum of effect size on the phenotype
df.InvQTNsum <- aggregate(qtnSelCoef~inv_id, FUN = sum, data = df.InvOrigin)
df.InvQTNnum <- aggregate(qtn_id~inv_id, FUN = length, data = df.InvOrigin)
df.InvOriginGen <- aggregate(sim_gen~inv_id, FUN = mean, data = df.InvOrigin)
df.InvQTNsumNum <- left_join(df.InvQTNsum, df.InvQTNnum, by = "inv_id")
colnames(df.InvQTNsumNum)[3] <- "origin_num_qtns"
df.InvQTNsumNumGen <- left_join(df.InvQTNsumNum, df.InvOriginGen, by = "inv_id")
colnames(df.InvQTNsumNumGen)[4] <- "origin_gen"

# merge inversion data with origin dynamics
df.InvDataOrigin <- left_join(df.invFinalGen, df.InvQTNsumNumGen, by = "inv_id")

# subset for MAF > 0.01
df.InvDataOriginMAF <- df.InvDataOrigin[df.InvDataOrigin$freq > 0.01,]
for(i in 1:nrow(df.InvDataOriginMAF)){
  if(df.InvDataOriginMAF$freq_p1[i] > df.InvDataOriginMAF$freq_p2[i]){
    df.InvDataOriginMAF$pop[i] <- "pop1"
  } else {
    df.InvDataOriginMAF$pop[i] <- "pop2"
    
  }
}

## Subset dataframe to get how the inversions change through time
inv.IDs <- as.vector(df.InvDataOriginMAF$inv_id)
df.invFinalAllData <- df.invTime[df.invTime$inv_id %in% inv.IDs, ]
df.invFinalAllData$qtnSelCoefsum <- df.invFinalAllData$mean_qtnSelCoef*df.invFinalAllData$num_qtns
df.invFinalAllDataPop <- left_join(df.invFinalAllData, df.InvDataOriginMAF[c(2,15)], by = "inv_id")

## Plotting
par(mfrow = c(1,3))
plot(origin_num_qtns~origin_gen, data = df.InvDataOriginMAF, xlab = "Inversion Origin Generation",
     ylab = "Origin number of QTNs in Inversion", col = "cornflowerblue", pch = 19, ylim = c(0, 400))
plot(num_qtns~origin_gen, data = df.InvDataOriginMAF, xlab = "Inversion Origin Generation",
     ylab = "Final number of QTNs in Inversion", col = "dodgerblue4", pch = 19, ylim = c(0, 400))
plot(qtnSelCoef~origin_gen, data = df.InvDataOriginMAF, xlab = "Inversion Origin Generation",
     ylab = "Sum of QTN effects on phenotype in Inversion", col = "cyan4", pch = 19)

## I DON'T THINK WE WANT
ggplot(df.InvDataOriginMAF, aes(x = origin_gen, y = qtnSelCoef, group = pop)) + 
  geom_point(aes(color = pop, size = inv_FST), alpha = 0.8) + 
  scale_color_manual(values=c("navy", "red")) + 
  theme_classic() +
  theme(panel.background = element_blank(), 
        strip.background = element_rect(colour = "white", fill = "grey92"),
        text = element_text(size = 15)) +
  labs(title = "Total Effect of Inversion QTNs on Phenotype",
       y = "sum of each Inversion QTNs \neffects on phenotype",
       x = "Inversion Origin Generation") +
  guides(color = guide_legend(title = "Pop with Highest\nFrequency of Inv")) +
  guides(size = guide_legend(title = "Inversion FST")) 

## All inversions from final generation through time (filtered by MAF > 0.01)
ggplot(df.invFinalAllDataPop, aes(x = sim_gen, y = qtnSelCoefsum, group = pop)) + 
  geom_point(aes(color = pop, size = inv_FST), alpha = 0.8) + 
  geom_line(aes(color = pop, group = inv_id), alpha = 0.8) + 
  scale_color_manual(values=c("navy", "red")) + 
  scale_size(range = c(0.5, 4), breaks = c(0.00001, 0.05, 0.15, 0.2)) + 
  theme_classic() +
  theme(panel.background = element_blank(), 
        strip.background = element_rect(colour = "white", fill = "grey92"),
        text = element_text(size = 15)) +
  labs(title = "Total Effect of Inversion QTNs on Phenotype",
       y = "sum of each Inversion QTNs \neffects on phenotype",
       x = "Generation") +
  guides(color = guide_legend(title = "Pop with Highest\nFrequency of Inv")) +
  guides(size = guide_legend(title = "Inversion FST")) 

## I DON"T THINK WE WANT
ggplot(df.invFinalAllDataPop, aes(x = sim_gen, y = qtnSelCoefsum, group = pop)) + 
  geom_point(aes(color = pop, size = inv_FST), alpha = 0.8) + 
#  geom_line(aes(color = pop), alpha = 0.8) + 
  scale_color_manual(values=c("navy", "red")) + 
  scale_size(range = c(0.5, 4), breaks = c(0.00001, 0.05, 0.15, 0.2)) + 
  theme_classic() +
  theme(panel.background = element_blank(), 
        strip.background = element_rect(colour = "white", fill = "grey92"),
        text = element_text(size = 15)) +
  labs(title = "Total Effect of Inversion QTNs on Phenotype",
       y = "sum of each Inversion QTNs \neffects on phenotype",
       x = "Generation") +
  guides(color = guide_legend(title = "Pop with Highest\nFrequency of Inv")) +
  guides(size = guide_legend(title = "Inversion FST")) 


# example <- df.invFinalAllDataPop[df.invFinalAllDataPop$sim_gen == 50000,][1,2]
# df.example <- df.invFinalAllDataPop[df.invFinalAllDataPop$inv_id == example,]
# 
# ggplot(df.example, aes(x = sim_gen, y = qtnSelCoefsum)) + 
#   geom_point(aes(color = pop, size = inv_FST), alpha = 0.8) + 
#   geom_line(aes(color = pop), alpha = 0.8) + 
#   scale_color_manual(values=c("navy", "red")) + 
#   scale_size(range = c(0.5, 4), breaks = c(0.00001, 0.05, 0.15, 0.2)) + 
#   theme_classic() +
#   theme(panel.background = element_blank(), 
#         strip.background = element_rect(colour = "white", fill = "grey92"),
#         text = element_text(size = 15)) +
#   labs(title = "Total Effect of Inversion QTNs on Phenotype",
#        y = "sum of each Inversion QTNs effects on phenotype",
#        x = "Generation") +
#   ylim(-0.2, 0.2) +
#   guides(color = guide_legend(title = "Pop with Highest\nFrequency of Inv")) +
#   guides(size = guide_legend(title = "Inversion FST")) 


df.invFinalsubset <- df.invFinalAllDataPop %>% filter(sim_gen %in% seq(0, 50000, by = 1000)) 

ggplot(df.invFinalsubset, aes(x = sim_gen, y = qtnSelCoefsum)) + 
  geom_point(aes(color = pop, size = inv_FST), alpha = 0.8) + 
  geom_line(aes(color = pop, group = inv_id), alpha = 0.8) + 
  scale_color_manual(values=c("navy", "red")) + 
  scale_size(range = c(0.5, 4), breaks = c(0.00001, 0.05, 0.15, 0.2)) + 
  theme_classic() +
  theme(panel.background = element_blank(), 
        strip.background = element_rect(colour = "white", fill = "grey92"),
        text = element_text(size = 15)) +
  labs(title = "Total Effect of Inversion QTNs on Phenotype",
       y = "sum of each Inversion QTNs effects on phenotype",
       x = "Generation") +
  ylim(-0.2, 0.2) +
  guides(color = guide_legend(title = "Pop with Highest\nFrequency of Inv")) +
  guides(size = guide_legend(title = "Inversion FST")) 


```
## VCF ##
```{r}

# Inspect Individual Data 
dim(df.indPheno)
head(df.indPheno)
tail(df.indPheno)

# Mutation stats at end of sim
# for all muts
dim(df.muts)
head(df.muts)
table(df.muts$type) 
hist(as.numeric(as.character(df.muts$FST)))
hist(df.muts$freq)

# inversion summary
head(df.invData)

# VCF file
#vcffile <- list.files(path=path, pattern=paste0(".vcf"))
#vcf <- read.vcfR(paste0(folder,seed, "_InversionVCF.vcf"))
vcf.MAF <- read.vcfR(paste0(folder,seed, "_InversionVCF_MAF01.recode.vcf"))

head(vcf.MAF)
head(vcf.MAF@fix, 50)
dim(vcf.MAF@fix)

# example of how to find a specific mutation in the vcf file
df.muts[2,]
vcf.MAF@fix[grep(df.muts$mutID[1], vcf.MAF@fix[,"INFO"]),]
  
geno <- vcf.MAF@gt[,-1] 
position <- getPOS(vcf.MAF)

if (sum(duplicated(position)) != 0){
  print("This simulation needs to be checked for duplicated locus positions")
}

G <- matrix(NA, nrow = nrow(geno), ncol = ncol(geno))
G[geno %in% c("0/0", "0|0")] <- 0
G[geno  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G[geno %in% c("1/1", "1|1")] <- 2

a_freq <- rowSums(G)/(2*ncol(G))
hist(a_freq) 

vcf_ind <- data.frame(vcf_ind=colnames(vcf.MAF@gt)[-1])
meta <- vcf.MAF@fix[,"INFO"]
head(meta)
length(meta)
length(regmatches(meta, regexpr("[0-9]+[0-9]", meta)))
vcf_muts <- data.frame(vcf_muts=vcf.MAF@fix[,8])
colnames(G) <- vcf_ind$vcf_ind # adds individual ids as column names
rownames(G) <- regmatches(meta, regexpr("[0-9]+[0-9]", meta)) #ADD MUTATION NAMES TO G
head(G[,1:5])
dim(G)

dim(vcf_ind)
head(vcf_ind)
head(df.indPheno)
df.indPheno$vcf_ind <- paste0("i",0:1999) # hard coding
# The individual IDs in Slim do not match the IDs in the VCF file. 
# I will assume they are in the same order
tail(df.indPheno)

indPhen_df_vcf <- merge(vcf_ind, df.indPheno, by="vcf_ind")
dim(df.indPheno)
dim(indPhen_df_vcf)

indPhen_df_vcf <- indPhen_df_vcf[order(indPhen_df_vcf$subpop, indPhen_df_vcf$id),]
head(indPhen_df_vcf)
tail(indPhen_df_vcf)

```


```{r}
pop1_ids <- which(indPhen_df_vcf$subpop==1)
pop2_ids <- which(indPhen_df_vcf$subpop==2)

G_pop1 <- G[, pop1_ids]
G_pop2 <- G[, pop2_ids]
dim(G_pop2)
head(G_pop1[,1:5])
head(G_pop2[,1:5])


# ## Population 1
 fordist <- as.data.frame(t(G_pop1))
 dist_mat <- dist(fordist, method="euclidean")
 dim(dist_mat)
 pop1_clust <- hclust(dist_mat, method = "ward.D")
 str(pop1_clust)
 pop1_order <- pop1_clust$order

#  ## Population 2
 fordist <- as.data.frame(t(G_pop2))
 dist_mat <- dist(fordist, method="euclidean")
 dim(dist_mat)
 pop2_clust <- hclust(dist_mat, method = "ward.D")
 str(pop2_clust)
 pop2_order <- pop2_clust$order

```



```{r}
# Why are we doing this for all allele affect sizes? shouldn't we just be looking at m2 mutations?

whichinversionmuts <- grep("MT=3", vcf.MAF@fix[,"INFO"]) #inversions

vcf.MAF@fix[whichinversionmuts,"INFO"]
info <- str_split(vcf.MAF@fix[,"INFO"], pattern =";", simplify=TRUE)
head(info)
# This took like an hour to figure out
a <- as.numeric(substring(info[,2], first=3)) #allele effect size
head(a)
hist(a, breaks=seq(-0.01, 0.01, length.out=101))
summary(a)
length(a)
dim(G)

dim(G_pop1)
head(G_pop1[,1:10])

G1_alpha <- G_pop1*a # make sure G and a line up
head(G1_alpha[,1:50])

hist(G1_alpha, breaks=seq(-0.02, 0.02, length.out=101))

G2_alpha <- G_pop2*a # make sure G and a line up
head(G2_alpha[,1:10])
hist(G2_alpha, breaks=seq(-0.02, 0.02, length.out=101))

hist(colSums(G1_alpha))
hist(colSums(G2_alpha))

# Sanity check - mutations in rows
head(G[1:100,1:10])
t(G1_alpha[1:100,9:10])

hist(G1_alpha)
hist(G2_alpha)
dim(G1_alpha)

```


```{r}
vcf_pos <- as.numeric(vcf.MAF@fix[,"POS"])
hist(vcf_pos, breaks=seq(0,2100000, length.out=100))
hist(df.muts$position, breaks=seq(0,2100000, length.out=100))

head(sort(df.muts$position))
head(vcf_pos)
df.muts$position_vcf <- df.muts$position + 1
df.muts$is_vcf <- NA

```


```{r}

hist(a)
a2 <- a
a2[a>0.001] <- 1
a2[a<0.001] <- -1


G1_alpha <- G_pop1*a2*G_FST # make sure G and a line up
G2_alpha <- G_pop2*a2*G_FST # make sure G and a line up

hist(G_pop1*a2)

# Sanity check - mutations in rows

heatmap(t(G1_alpha[, pop1_order]),   
        main="Pop1 G*a+-*FST",cexCol = 0.3,
           Colv = NA, useRaster=TRUE,
        scale="none",
        # Rowv = NA, 
       col=two.colors(100, start = "blue", end="red", middle="white") )
      # ADDING BREAKS SCREWS UP EVERYTHING
        #breaks=seq(-0.005, 0.005, length.out = 101))

heatmap(t(G2_alpha[, pop2_order]),   
        main="Pop2 G*a+-*FST",cexCol = 0.3,
         Colv = NA, useRaster=TRUE,
       scale="none",
       #  Rowv = NA, 
       col=two.colors(100, start = "blue", end="red", middle="white") )

```


```{r}

G_ref1 <- G_pop1
G_ref2 <- G_pop2

af_pop1 <- rowSums(G_pop1)/(2*ncol(G_pop1))
af_pop2 <- rowSums(G_pop2)/(2*ncol(G_pop2))
hist(af_pop1)
hist(af_pop2)
todo <- which(af_pop1>af_pop2)

todo_homo <- which(G[,1]==2)
for (i in todo_homo){
  G_ref1[i,] <- abs(G_pop1[i,]-2)
  G_ref2[i,] <- abs(G_pop2[i,]-2)
}

todo_hetero <- which(G[,1]==1 & af_pop1>af_pop2)
for (i in todo_hetero){
  G_ref1[i,] <- abs(G_pop1[i,]-2)
  G_ref2[i,] <- abs(G_pop2[i,]-2)
}

table(G_ref1[,1])

table(G_ref1)
table(G_ref2)
table(G_isInvWindow)



heatmap(t(G_ref1[,pop1_order]), Rowv = NA,  main="Pop1 genotypes",cexCol = 0.3,
             Colv = NA, useRaster=TRUE,
        scale="none")


heatmap(t(G_ref2[,pop2_order]), Rowv = NA,  main="Pop2 genotypes",cexCol = 0.3,
             Colv = NA, useRaster=TRUE,
        scale="none")




```