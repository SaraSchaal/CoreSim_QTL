initialize(){
	
	
	//////////////////////////////////////////////////////////////////
	// X X X X X Define Constants and Initialize Elements X X X X X //
	//////////////////////////////////////////////////////////////////
	
	//setSeed(1528533727450);  // to make code reproducible need to define a seed that will be used 
	
	if(exists("slimgui")){
		
		seed = getSeed();
		setwd("~/Documents/Northeastern/LotterhosLab/Coding/SLiM/CoreSim_QTL/results/Inversion/");
		path = getwd();
		defineConstant("MYPATH", path);						// set the path on your computer for writing files
		defineConstant("MYSEED", seed);						// set random number generator can be fixed at earlier argument for reproducibility
		defineConstant("C_NUM", 21);							// number of chromosomes
		defineConstant("C_LENGTHS", rep(1e5, C_NUM));	// lengths for each chromosome
		defineConstant("MU_base", 1e-8);						// base mutation rate overall
		defineConstant("MU", MU_base * 0.1);	// 0.02			// mut rate for QTNs specifically
		defineConstant("MU_INV", 2e-4);		// 2e-6				// inversion generation (ind^-1) (gen^-1)
		defineConstant("R", 1e-6);								// recombination rate
		defineConstant("N", 1000);								// subpop size
		defineConstant("MIG1", 0.01);							// migration rate into p1
		defineConstant("MIG2", 0.01);							// migration rate into p2
		defineConstant("THETA", c(1.0, -1.0));				// optima after burn in P1
		defineConstant("SIGMA_K", 1.5);						// QT selection strength
		defineConstant("BURNIN", 4000);						// number of burning generations 
		defineConstant("ENVAR", 0.01);							// environmental variance 
		defineConstant("ALPHA", 0.7);							// SD of the normal distribution of effect sizes
		defineConstant("TREESIM", 500); 						// generation increment for TreeSeq simplification
		defineConstant("DOM", T);								// Turn on/off dominance
	
	} // end defining constants
	
	//initializeTreeSeq(simplificationInterval=TREESIM);	// infrequent for faster runtimes
	initializeMutationRate(MU);
	
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 0.5, "n", 0.0, ALPHA);	// QTNs, can alter ALPHA for different SD of the normal distribution
	m2.convertToSubstitution = F;
	initializeMutationType("m3", 0.5, "f", 0.0);			// inversions
	m3.convertToSubstitution = T;								// allow inversion muts to fix
	m3.color = "yellow";
	
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElementType("g2", m1, 1.0);
	initializeGenomicElement(g1, 0, sum(C_LENGTHS[0:(C_NUM - 2)]));
	initializeGenomicElement(g2, sum(C_LENGTHS[0:(C_NUM - 2)])+1, sum(C_LENGTHS[0:(C_NUM - 1)]));
	
	rates = c(rep(c(R, 0.5), C_NUM-1), R);
	ends = repEach(cumSum(C_LENGTHS), 2);
	ends = ends[0:(length(ends) - 2)];
	ends = ends + c(rep(c(0,1), C_NUM-1), 0);
	initializeRecombinationRate(rates, ends);

} // end initalization


1 early() {
	
	//////////////////////////////////////////////////////////////
	/// X X X Define Starting Populations & File Headers X X X ///
	//////////////////////////////////////////////////////////////
	//////////// Events in this loop only occur once /////////////
	
	sim.addSubpop("p1", N);
	sim.addSubpop("p2", N);
	p1.setMigrationRates(p2, MIG1);
	p2.setMigrationRates(p1, MIG2);
	
	out_head = "Gen " + "uniqueInvMuts " + "localAdaptSA " + "localAdaptHA_P1 " + "localAdaptHA_P2 " + "localAdaptLF_P1 " +
			  	  "localAdaptLF_P2 " + "meanFST_QTNs " + "upCI_FST_QTNs " + "lowCI_FST_QTNs " + + "meanFST_invs " + "upCI_FST_invs " + 
			  	  "lowCI_FST_invs " + "meanFST_neut " + "upCI_FST_neut " + "lowCI_FST_neut " + "meanFitP1 " + "sdFitP1 " +
					"meanPhenoP1 " + "sdPhenoP1 " + "meanFitP2 " + "sdFitP2 " + "meanPhenoP2 " + "sdPhenoP2 " + "\n";
	writeFile(paste(c(MYPATH, "/", MYSEED, "_outputPhenFit.txt"), sep = ""), out_head);
	
	
	outINV_head = "Gen " + "start_position " + "end_position " + "lengthINV " + "freq " + "freq_p1 " +
		"freq_p2 " + "mean_SelCoef " + "sd_SelCoef " + "mean_Dom " + "sd_Dom " + "\n";
	writeFile(paste(c(MYPATH, "/", MYSEED, "_outputINVsum.txt"), sep = ""), outINV_head);

} // end population defining


mutation(m2) {
	
	// draw a dominance coefficient for QTN mutations
	mut.setValue("dom", runif(1));
	return T;

}


fitness(m2) { return 1.0; }


late() {
	// generate inversions by randomly selecting an individual to gain an inversion at a probability of MU_INV
	inds = sim.subpopulations.individuals;
	inv_draws = rbinom(inds.size(), 1, prob=MU_INV);
	
	// step through inversion draws and place in individuals genome at a random location and size according 
	// to a uniform distribution
	for (index in which(inv_draws > 0))
	{
		ind = inds[index];
		
		// draw the inversion position / length
		chrom_index = rdunif(1, min=0, max=C_NUM-1);
		inv_length = rdunif(1, min=100, max=integerDiv(C_LENGTHS[chrom_index], 2));
		chrom_start = sum(C_LENGTHS[seqLen(chrom_index)]);
		inv_start = rdunif(1, min=chrom_start, max=chrom_start + C_LENGTHS[chrom_index] - inv_length);
		
		// check for overlap with existing inversions
		genome = sample(ind.genomes, 1);
		existing = genome.mutationsOfType(m3);
		overlaps = F;
		for (e in existing){
			
			e_start = e.position;
			e_end = e_start + e.tag;
			
			if ((inv_start <= e_end) & (inv_start + inv_length - 1 >= e_start)){
				
				overlaps = T;
				break;
			
			}
		}
		
		if (overlaps)
			next;
		
		// generate the inversion; m3 tags record the length of the inversion mut
		inv_mut = genome.addNewDrawnMutation(m3, inv_start);
		inv_mut.tag = inv_length;
	
	}
}

// this recombination callback should cause the inversion to indirectly be under frequency-dependent selection
// there is no DIRECT selection on the inversion
recombination() {
	
	g1_invs = genome1.mutationsOfType(m3);
	g2_invs = genome2.mutationsOfType(m3);
	unshared_invs = setSymmetricDifference(g1_invs, g2_invs); // all heterozygous individuals
	
	// heterozygous individuals will not have recombination between homologous regions because
	// they will not line up properly
	// homozygous individuals will have normal recombination because the chromosomes line up which can 
	// then break apart the loci found in the inversion (*essentially frequency dependent selection*)
	
	if (size(unshared_invs) == 0) // if no het
		return F;
	removed_any = F;
	
	for (inv in unshared_invs){
		
		// define the start and end position of the inversion
		start = inv.position;
		end = start + inv.tag;
		
		// the positions of proposed breakpoints are supplied to the callback by SLiM in the "breakpoints" variable
		// This variable is generated when recombination occurs and can be overwritten as we do below
		inInv = (breakpoints > start) & (breakpoints <= end);
		if (any(inInv)){
			
			// *****finds any breakpoints that were made during the recombination step that fall within
			// the inversion and removes them*********
			breakpoints = breakpoints[!inInv];
			removed_any = T;
		}
	}
	return removed_any;
}

late(){
	
	for (subpop_index in seqAlong(sim.subpopulations)) {
		
		subpop = sim.subpopulations[subpop_index];
		optimum = THETA[subpop_index]; //* optimum_scaling;
		inds = subpop.individuals;
		
		if (DOM){
			// dominance effects: heterozygotes are h*2*alpha, homozygotes are 2*alpha
			for (ind in inds){
				g1_m2 = ind.genome1.mutationsOfType(m2);
				g2_m2 = ind.genome2.mutationsOfType(m2);
				
				hom = setIntersection(g1_m2, g2_m2);
				het = setSymmetricDifference(g1_m2, g2_m2);
				
				phenotype = 0.0;
				if (size(hom))
					phenotype = sum(hom.selectionCoeff * 2.0);
				if (size(het))
					phenotype = phenotype + sum(het.selectionCoeff * 2.0 * het.getValue("dom"));
				ind.tagF = phenotype;
			
			}
			
			phenotypes = inds.tagF + rnorm(1, mean = 0, sd = ENVAR);
		
		} else {
			
			// no dominance effects: heterozygotes are alpha, homozygotes are 2*alpha
			phenotypes = inds.sumOfMutationsOfType(m2);
			inds.tagF = phenotypes;				// store phenotypes for output
		
		}
		
		if(sim.generation < BURNIN){ /// burnin period where mutations are arising but no affect on fitness
			
			fitness = 1.0;
			inds.fitnessScaling = fitness;
		
		} else {
			
			fitness = dnorm(phenotypes, optimum, sd=SIGMA_K) / dnorm(0.0, 0.0, sd=SIGMA_K);
			inds.fitnessScaling = fitness;
		
		}
	}
}

early(){
	
	
	//////////////////////////////////////////////////
	// X X X X X Population Level Outputs X X X X X //
	//////////////////////////////////////////////////
	
	if (sim.generation % 200 == 0){
		
		inds = sim.subpopulations.individuals;
		genomes = inds.genomes;
		
		catn("================================ " + sim.generation);
		catn("m3 mutations segregating: " + size(sim.mutationsOfType(m3)));
		
		for (mut in sim.mutationsOfType(m3)) {
			
			// X X Summary Stats for Each Inversion
			pos = mut.position;														// start of inversion
			len = mut.tag;																// length of inversion
			end = pos + len - 1;														// end of inversion
			mut_genomes = genomes[genomes.containsMutations(mut)];		// genomes with inversion
			non_mut_genomes = genomes[!genomes.containsmutations(mut)]; // genomes without inversion
			freq = size(mut_genomes) / size(genomes);							// frequency of inversion
			freq_p1 = sim.mutationFrequencies(p1, mut);						// frequency of inversion in pop 1
			freq_p2 = sim.mutationFrequencies(p2, mut);						// frequency of inversion in pop 2
			
			// output meta information about the inversion
			if(mut.originGeneration - sim.generation < 200){ 
				outINVmeta = paste(c(mut.id, sim.generation, pos, end, len), sep = " ");
			}
			writeFile(paste(c(MYPATH, "/", MYSEED, "_outputInvMetaInfo.txt"), sep = ""), outINVmeta, append = T);
			
			// X X Summary Stats of any QTNs within Inversion
			QTNsINInvGenomes = mut_genomes.mutationsOfType(m2);				// find all m2 mutations within those genomes with inversion
			QTNsOtherGenomes = non_mut_genomes.mutationsOfType(m2);			// QTNS in genomes without the inversion
			QTNsIN = QTNsIN[QTNs.position >= pos & QTNs.position <= end];	// all those m2 mutations only inside the inversion
			
			/// step through all QTNs that fall within inversion and get summary info
			if(size(QTNsIN) > 0){
			
				QTNsPreInv = setIntersection(QTNsIN, QTNsOtherGenomes);
				
				if(length(QTNsPreInv) > 0){
					for(j in 0:size(QTNsPreInv)){
						genomesWOInvWQTN = QTNsOtherGenomes[containsMutations(QTNsPreInv[i])];
						freqOutInv = size(genomesWOInvWQTN) / size(genomes);
						genomesWInvWQTN = QTNsInInvGenomes[containsMutation(QTNsPreInv[i])];
						freqInInv = size(genomesWInvWQTN);
				} else {
				
				for(i in 0:size(QTNsIN)){
					
					if(QTNsIN 
						QTNpositions = QTNsIN.position;
						freq_P1_InvQTNsUniq = sim.mutationFrequencies(p1, QTNsIN); // frequency of inversion QTN pop 1
						freq_P2_InvQTNsUniq = sim.mutationFrequencies(p2, QTNsIN);	// frequency of inversion QTN pop 2
						freq_InvQTNsUniq = sim.mutationFrequencies(NULL, QTNsIN);	// frequency of inversion QTN overall
						InvQTNsSelCoeffUniq = QTNsIN.selectionCoeff;					// selection coefficients of all QTNs
						InvQTNsDomUniq = QTNsIN.getValue("dom");						// dominance value of each QTN
						InvQTNsSubpop = QTNsIN.subpopID;									// subpop ID for each QTN
						InvQTNsID = QTNsIN.id;												// QTN ID
			} else {
				InvQTNsSelCoeffUniq = 0;											// give selection coefficient 0 if no qtns for later calcs
				InvQTNsDomUniq = 0;													// give dominance value 0 if no qtns for later calcs
			}
			
			
			QTNsOut = QTNs[!QTNs.position >= pos & QTNs.position <= end]; // find all m2 mutations outside inversion
			
			// X X output some stats as simulation runs 
			cat("pos = " + pos + ", len = " + len + "\n" + "freq = " +
				freq + "\n" + "p1_freq = " + freq_p1 + ", p2_freq = " +
				freq_p2 + "\n");
			
			/// X X X Print Out 
			catn("Number of QTNs in Inv = " + size(QTNs));
			catn("QTN Effect Sizes = " + unique(InvQTNsSelCoeffUniq));
			catn("Num genomes w/ INV =" + size(mut_genomes));
			catn("QTN Position = " + unique(QTNpositions));
			catn("------" + "\n");
											
			outINV = paste(c(mut.id, sim.generation, freq, freq_p1, freq_p2, size(QTNsIN), mean(InvQTNsSelCoeff), sd(InvQTNsSelCoeff), 
								  mean(InvQTNsDom), sd(InvQTNsDom)), sep = " ");
			
			for (i in 0:(size(QTNs) - 1)){
					
				outINVQTNmetaData = sim.generation + " " + mut.originGeneration + " " + QTNs.originGeneration[i] + " " + pos +
										  " " + QTNpositions[i] + " " + InvQTNsSelCoeffUniq[i] + " " + InvQTNsDomUniq[i] + " " +
										   freq_P1_InvQTNsUniq[i] + " " + freq_P2_InvQTNsUniq[i] + " " + freq_InvQTNsUniq[i] + "/n";
						
				writeFile(paste(c(MYPATH, "/", MYSEED, "_outputInvQTNData.txt"), sep = ""), outINVQTNmetaData, append = T);
			}
								
			outINV = paste(c(sim.generation, pos, end, len, freq, freq_p1, freq_p2, mean(InvQTNsSelCoeff),
				sd(InvQTNsSelCoeff), mean(InvQTNsDom), sd(InvQTNsDom)), sep = " ");
				
			writeFile(paste(c(MYPATH, "/", MYSEED, "_outputINVsum.txt"), sep = ""), outINV, append = T);

			// output files		 	
			
		
		} // close for loop for stepping through each inversion mutation 
		
		
		///////////////////////////////////////////////////
		// X X X X LOCAL ADAPTATION CALCULATIONS X X X X //
		///////////////////////////////////////////////////
		
		// X X Fitness in Opposite Population 
		opPopOptimumP1 = NULL;
		opPopOptimumP2 = NULL;
		opPopFitnessP1 = NULL;
		opPopFitnessP2 = NULL;
		for (subpop_index in seqAlong(sim.subpopulations)) {
			subpop = sim.subpopulations[subpop_index];
			inds = subpop.individuals;
			if(subpop == p1) {
				opPopOptimumP1 = THETA[1];
				for(ind in inds){
					opPopFitnessP1 = c(opPopFitnessP1, dnorm(ind.tagF, opPopOptimumP1, sd=SIGMA_K) /
						dnorm(0.0, 0.0, sd = SIGMA_K));
				}
			} else {
				opPopOptimumP2 = THETA[0];
				for(ind in inds){
					opPopFitnessP2 = c(opPopFitnessP2, dnorm(ind.tagF, opPopOptimumP2, sd=SIGMA_K) /
						dnorm(0.0, 0.0, sd = SIGMA_K));
				} // close inds for loop
			} // close if/else
		} // close subpop for loop
		
		// home vs away local adaptation 
		locAdaptHAP1 = mean(p1.cachedFitness(NULL)) - mean(opPopFitnessP1); // pop1 in pop1 vs pop1 in pop2
		locAdaptHAP2 = mean(p2.cachedFitness(NULL)) - mean(opPopFitnessP2); // pop2 in pop2 vs pop2 in pop 1
		
		// sympatric vs allopatric
		locAdaptSA = mean(c(p1.cachedFitness(NULL), p2.cachedFitness(NULL))) -
			mean(c(opPopFitnessP1, opPopFitnessP2));
		
		// local vs foreign local adaptation
		locAdaptLFP1 = mean(p1.cachedFitness(NULL)) - mean(opPopFitnessP2); // pop1 in pop1 vs pop2 in pop1
		locAdaptLFP2 = mean(p2.cachedFitness(NULL)) - mean(opPopFitnessP1); // pop2 in pop2 vs pop1 in pop2
		
		//////////////////////////////////////		
		// X X X X FST Calculations X X X X //	
		//////////////////////////////////////	
		
	  	//// X X QTNS X X ////
		
		g = sim.subpopulations.genomes;
		// unique mutations sorted by position
		m = sortBy(unique(c(g.mutationsOfType(m2))), "position");
		m_freqs = sim.mutationFrequencies(NULL, m);
		wtype_freqs = 1 - m_p1freqs;
		
		// filter out minor allele frequencies < 0.05 before calculating FST
		MAF = NULL;
		filteredQTNs = NULL;
		for(i in 1:length(m_freqs)){
			MAF = min(m_freqs[i], wtype_freqs[i]);
			if(MAF < 0.05){
				filteredQTNs = c(filteredQTNs, m.id[i]);
			}
		}
		m_filt = m.id[!filteredQTNs];
		
		// frequency of mutation in P1
		m_p1freqs = sim.mutationFrequencies(p1, m_filt);
		// frequency of mutation in P2
		m_p2freqs = sim.mutationFrequencies(p2, m_filt);	
		
		//// FST Calculation QTNs
		
		// expected Heterozygosity
		expH_p1 = m_p1freqs * (1 - m_p1freqs) * 2;
		expH_p2 = m_p2freqs * (1 - m_p2freqs) * 2;
		// HS
		HS = (expH_p1 * N + expH_p2 * N)/(N * 2);
		// HT calculate overall heterozygosity
		pBar = (m_p1freq * N + m_p2freq * N)/(N * 2);
		// adding N in in case anyone uses this with unequal pop sizes not needed for my simulation
		qBar = 1 - pBar;
		HT = 2 * pBar * qBar;
		// FST
		FST = 1 - (HS/HT);
		
		// mean FST and 95% CIs 
		FSTBar =	mean(FST);
		StErr = sd(FST)/sqrt(length(FST));
		upCI = FSTBar + (StErr*1.96);
		lowCI = FSTBar - (StErr*1.96);
		
		
		//// X X Inversions X X ////
		
		m_inv = sortBy(unique(c(g.mutationsOfType(m3))), "position");
		m_inv_freqs = sim.mutationFrequencies(NULL, m_inv);
		wtype_inv_fres = 1 - m_inv_freqs;
		
		// filter out minor allele frequencies < 0.05 before calculating FST
		inv_MAF = NULL;
		filteredinvs = NULL;
		for(i in 1:length(m_inv_freqs)){
			inv_MAF = min(m_inv_freqs[i], wtype_inv_freqs[i]);
			if(inv_MAF < 0.05){
				filteredinvs = c(filteredinvs, m_inv.id[i]);
			}
		}
		m_inv_filt = m_neut.id[!filteredneut];
		
		// frequency of inversion mutation in P1
		m_inv_p1freqs = sim.mutationFrequencies(p1, m_inv_filt);
		// frequency of inversion mutation in P2
		m_inv_p2freqs = sim.mutationFrequencies(p2, m_inv_filt);
		
		//// FST Calculation Inversions 
		
		// expected Heterozygosity
		inv_expH_p1 = m_inv_p1freqs * (1 - m_inv_p1freqs) * 2;
		inv_expH_p2 = m_inv_p2freqs * (1 - m_inv_p2freqs) * 2;
		// HS
		inv_HS = (inv_expH_p1 * N + inv_expH_p2 * N)/(N * 2);
		// HT calculate overall heterozygosity
		inv_pBar = (m_inv_p1freq * N + m_inv_p2freq * N)/(N * 2);
		// adding N in in case anyone uses this with unequal pop sizes not needed for my simulation
		inv_qBar = 1 - inv_pBar;
		inv_HT = 2 * inv_pBar * inv_qBar;
		// FST
		inv_FST = 1 - (inv_HS/inv_HT);
		
		// mean FST and 95% CIs 
		inv_FSTBar =	mean(inv_FST);
		inv_StErr = sd(inv_FST)/sqrt(length(inv_FST));
		inv_upCI = inv_FSTBar + (inv_StErr * 1.96);
		inv_lowCI = inv_FSTBar - (inv_StErr * 1.96);
		
		//// X X Neutral X X ////
		
		m_neut = sortBy(unique(c(g.mutationsOfType(m1))), "position");
		m_neut_freqs = sim.mutationFrequencies(NULL, m_neut);
		wtype_neut_fres = 1 - m_neut_freqs;
		
		// filter out minor allele frequencies < 0.05 before calculating FST
		neut_MAF = NULL;
		filterednet = NULL;
		for(i in 1:length(m_neut_freqs)){
			neut_MAF = min(m_neut_freqs[i], wtype_neut_freqs[i]);
			if(neut_MAF < 0.05){
				filteredneut = c(filteredneut, m_neut.id[i]);
			}
		}
		m_neut_filt = m_neut.id[!filteredneut];
		
		// frequency of inversion mutation in P1
		m_neut_p1freqs = sim.mutationFrequencies(p1, m_neut_filt);
		// frequency of inversion mutation in P2
		m_neut_p2freqs = sim.mutationFrequencies(p2, m_neut_filt);
		
		//// FST Calculation Inversions 
		
		// expected Heterozygosity
		neut_expH_p1 = m_neut_p1freqs * (1 - m_neut_p1freqs) * 2;
		neut_expH_p2 = m_neut_p2freqs * (1 - m_neut_p2freqs) * 2;
		// HS
		neut_HS = (neut_expH_p1 * N + neut_expH_p2 * N)/(N * 2);
		// HT calculate overall heterozygosity
		neut_pBar = (m_neut_p1freq * N + m_neut_p2freq * N)/(N * 2);
		// adding N in in case anyone uses this with unequal pop sizes not needed for my simulation
		neut_qBar = 1 - neut_pBar;
		neut_HT = 2 * neut_pBar * neut_qBar;
		// FST
		neut_FST = 1 - (neut_HS/neut_HT);
		
		// mean FST and 95% CIs 
		neut_FSTBar =	mean(neut_FST);
		neut_StErr = sd(neut_FST)/sqrt(length(neut_FST));
		neut_upCI = neut_FSTBar + (neut_StErr * 1.96);
		neut_lowCI = neut_FSTBar - (neut_StErr * 1.96);
		
		outIndSum = paste(c(sim.generation, size(sim.mutationsOfType(m3)), locAdaptSA, locAdaptHAP1, locAdaptHAP2, locAdaptLFP1,
			locAdaptLFP2, FSTBar, upCI, lowCI, inv_FSTBar, inv_upCI, inv_lowCI, neut_FSTBar, neut_upCI, neut_lowCI, 
			mean(p1.cachedFitness(NULL)), sd(p1.cachedFitness(NULL)), mean(p1.individuals.tagF), sd(p1.individuals.tagF), 
			mean(p2.cachedFitness(NULL)), sd(p2.cachedFitness(NULL)), mean(p2.individuals.tagF), sd(p2.individuals.tagF)), sep = " ");
		
		writeFile(paste(c(MYPATH, "/", MYSEED, "_outputPhenFit.txt"), sep = ""), outIndSum, append = T);
	
	} // close if statement for outputting every X generations
} // close late event

200000 late(){
	
	//////////////////////////////////////////
	// X X X X X Simulation Stats X X X X X //
	//////////////////////////////////////////
	
	output_sim = paste(c(MYSEED, MIG1, MIG2, p1.individualCount, p2.individualCount, MU, MU_INV, R, ALPHA, SIGMA_K, BURNIN, DOM, ENVAR), sep = " ");
	
	writeFile(paste(c(MYPATH, "/", MYSEED, "_outputSimStats.txt"), sep = ""), output_sim);
	
	//////////////////////////////////////////////////
	// X X X X X Individual Level Outputs X X X X X //
	//////////////////////////////////////////////////
	
	// X X Individual genomes 
	
	inds = sim.subpopulations.individuals;
	inds.genomes.outputVCF(paste(c(MYPATH, "/", MYSEED, "_CoreSimQTL_sim1pop1.vcf"), sep= ""));
	
	// X X X X Phenotypes & Number of Heterozygous vs Homozygous Individuals for Each Inversion 
	
	output_ind = "id " +  "subpop " + "phenotype " + "\n"; // create header for file
	
	// for loop to step through individuals and pull first the header then append new lines with 
	// individual index information which subpopulation they are from and their phenotype
	
	homLoci = NULL;
	hetLoci = NULL;
	allLoci = NULL;
	
	for(ind in inds){
		
		// output phenotypes
		output_ind = output_ind + ind.index + " " + ind.subpopulation.id + " " + ind.tagF + "\n";
		
		// identify homozygotes and heterozygotes for inversions for later calculation
		g1_m3 = ind.genome1.mutationsOfType(m3);							// first genome with inversion
		g2_m3 = ind.genome2.mutationsOfType(m3);							// second genome with inversion
		g1_m2 = ind.genome1.mutationsOfType(m2);							// first genome with qtn
		g2_m2 = ind.genome2.mutationsOfType(m2);							// second genome with qtn
		homInvLoci = c(homInvLoci, setIntersection(g1_m3, g2_m3)); 	// when each genome has the inversion = homozygous
		homQTNLoci = c(homQTNLoci, setIntersection(g1_m2, g2_m2));  // when each genome has qtn = homozygous
		hetInvLoci = c(hetInvLoci, setSymmetricDifference(g1_m3, g2_m3));	// when only one genome has the inversion = heterozygous
		hetQTNLoci = c(hetQTNLoci, setSymmetricDifference(g1_m2, g2_m2)); // when only one genome has the qtn = heterozygous
		allInvLoci = c(allInvLoci, homInvLoci, hetInvLoci);			// append all inv loci together
		allQTNLoci = c(allQTNLoci, homQTNLoci, hetQTNLoci);			// append all qtn loci together
	}
	
	// write Individual. Phenotype file to working directory 
	writeFile(paste(c(MYPATH, "/", MYSEED, "_Inv_outputIndPheno.txt"), sep = ""), output_ind);
	
	// X X X Calculation heterozygosity and homozygosity for inversions
	InvHeterozygosity = NULL;
	InvMutID = NULL;
	for(InvMut in unique(allInvLoci.id)){
		
		homInvCount = 0;
		hetInvCount = 0;
		for(HO in homInvLoci){
			if(InvMut == HO.id){
				homInvCount = homInvCount + 1;
			}
		}
		
		for(HE in hetInvLoci){
			if(InvMut == HE.id){
				hetInvCount = hetInvCount + 1;
			}
		}
		
		homInv = homInvCount/sum(c(homInvCount,hetInvCount));
		hetInv = hetInvCount/sum(c(homInvCount,hetInvCount));
		InvMutID = c(InvMutID, InvMut);
		InvHeterozygosity = c(InvHeterozygosity, hetInv);
	
	}
	
	// X X X Calculation heterozygosity and homozygosity for QTNs 
	heterozygosity = NULL;
	MutID = NULL;
	for(QTNMut in unique(allQTNLoci.id)){
		
		homCount = 0;
		hetCount = 0;
		for(HO in homQTNLoci){
			if(QTNMut == HO.id){
				homCount = homCount + 1;
			}
		}
		
		for(HE in hetQTNLoci){
			if(QTNMut == HE.id){
				hetCount = hetCount + 1;
			}
		}
		
		hom = homCount/sum(c(homCount,hetCount));
		het = hetCount/sum(c(homCount,hetCount));
		MutID = c(MutID, QTNMut);
		heterozygosity = c(heterozygosity, het);
	
	}
	
	//// X X Mutations X X ////
	
	//////////
	// QTNS //
	//////////
	g = sim.subpopulations.genomes;
	// unique mutations sorted by position
	m = sortBy(unique(c(g.mutationsOfType(m2))), "position");
	m_freqs = sim.mutationFrequencies(NULL, m);
	wtype_freqs = 1 - m_p1freqs;
	
	// filter out minor allele frequencies < 0.05 before calculating FST
	MAF = NULL;
	filteredQTNs = NULL;
	for(i in 1:length(m_freqs)){
		MAF = min(m_freqs[i], wtype_freqs[i]);
		if(MAF < 0.05){
			filteredQTNs = c(filteredQTNs, m.id[i]);
		}
	}
	m_filt = m.id[!filteredQTNs];
	
	
	// frequency of mutation in P1
	m_p1freqs = sim.mutationFrequencies(p1, m);
	// frequency of mutation in P2
	m_p2freqs = sim.mutationFrequencies(p2, m);
	// adaptive phenotypic divergence per locus
	adapPhenoDiv = 2 * ALPHA * (m_p2freqs - m_p1freqs);
	
	//////////////////////////
	// FST Calculation QTNs //
	//////////////////////////
	// expected Heterozygosity
	expH_p1 = m_p1freqs * (1 - m_p1freqs) * 2;
	expH_p2 = m_p2freqs * (1 - m_p2freqs) * 2;
	// HS
	HS = (expH_p1 * N + expH_p2 * N)/(N * 2);
	// HT calculate overall heterozygosity
	pBar = (m_p1freq * N + m_p2freq * N)/(N * 2);
	// adding N in in case anyone uses this with unequal pop sizes not needed for my simulation
	qBar = 1 - pBar;
	HT = 2 * pBar * qBar;
	// FST
	FST = 1 - (HS/HT);
		
	//////////////////////////////
	// output for QTN mutations //
	//////////////////////////////
	out_m = "position " + "mutID " + "selCoef " + "originGen " + "type " + "freq " + "p1freq " + "p2freq " +
		"adapPhenoDiv " + "FST " + "heterozygosity " + "homozygosity " + "\n";
	
	// for loop to step through mutations and pull the header then append new lines with
	// mutation position, the selection coefficient, the generation the mutation originated from and 
	// its frequency
	for(i in 0:(size(m)-1)){
		out_m = out_m + m.position[i] + " " + m.id[i] + " " + m.selectionCoeff[i] + " " + m.originGeneration[i] + " " + "m2 " +
			m_freqs[i] + " " + m_p1freqs[i] + " " + m_p2freqs[i] + " " + adapPhenoDiv[i] + FST[i] + "\n";
	}
	
	writeFile(paste(c(MYPATH, "/", MYSEED, "_outputMutations.txt"), sep = ""), out_m);
	
}


//1:20000 {
//	if (sim.generation%TreeSim==0)
//		sim.treeSeqSimplify();
//}

200001 late() {
	sim.outputFixedMutations();
}










